<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ontology Checks - Phase 3</title>
</head>
<body>
  <h1>Ontology Checks - Phase 3</h1>

  <p>
    Select an ontology file (e.g., TTL) and click "Run checks".<br />
    Results will be logged to the browser console, and a per-resource curation table will appear below.
  </p>

  <input type="file" id="ontologyFile" accept=".ttl,.rdf,.owl,.nt,.nq,.trig,.jsonld" />
  <button id="runChecksBtn">Run checks</button>
  <button id="downloadResultsCsvBtn">Download Results CSV</button>
  <button id="downloadOntologyYamlBtn">Download Ontology Report YAML</button>

  <pre id="status"></pre>

  <!-- Container for the ontology-level report -->
  <div id="ontologyReportContainer"></div>

  <!-- Container for the per-resource curation table -->
  <div id="curationTableContainer"></div>


  <script src="app/n3.min.js"></script>
  <script src="app/comunica-browser.js"></script>

  <script type="module" src="app/main.js"></script>
  
  <script type="module" src="app/engine.js"></script>
  <script type="module" src="app/grader.js"></script>

  
  <!-- 4) Wire the UI to the engine + grader -->
  <script>
    const fileInput = document.getElementById('ontologyFile');
    const btnRun = document.getElementById('runChecksBtn');
    const btnCsv = document.getElementById('downloadResultsCsvBtn');
    const btnYaml = document.getElementById('downloadOntologyYamlBtn');
    const statusEl = document.getElementById('status');
    const tableContainer = document.getElementById('curationTableContainer');
    const ontologyReportContainer = document.getElementById('ontologyReportContainer');

    let lastResults = null;
    let lastPerResource = null;
    let lastOntologyReport = null;

    function escapeHtml(str) {
      if (str == null) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function renderCurationTable(perResource) {
      if (!perResource || perResource.length === 0) {
        tableContainer.innerHTML = '<p>No curation results to display.</p>';
        return;
      }

      let html = '<h2>Per-resource curation</h2>';
      html += '<table border="1" cellpadding="4" cellspacing="0">';
      html += '<thead><tr>' +
              '<th>Resource</th>' +
              '<th>Curation Status</th>' +
              '<th>Failed Requirements</th>' +
              '<th>Failed Recommendations</th>' +
              '</tr></thead><tbody>';

      for (const row of perResource) {
        const reqs = row.failedRequirements.join(', ') || '—';
        const recs = row.failedRecommendations.join(', ') || '—';

        html += '<tr>' +
                '<td>' + escapeHtml(row.resource) + '</td>' +
                '<td>' + escapeHtml(row.statusLabel) + '</td>' +
                '<td>' + escapeHtml(reqs) + '</td>' +
                '<td>' + escapeHtml(recs) + '</td>' +
                '</tr>';
      }

      html += '</tbody></table>';
      tableContainer.innerHTML = html;
    }

    function renderOntologyReport(report) {
      if (!report) {
        ontologyReportContainer.innerHTML = '';
        return;
      }

      let html = '<h2>Ontology report card</h2>';
      html += '<p><strong>Ontology IRI:</strong> ' + escapeHtml(report.ontologyIri) + '</p>';
      html += '<p><strong>Ontology curation status:</strong> ' + escapeHtml(report.statusLabel) + '</p>';

      if (!report.requirements || report.requirements.length === 0) {
        html += '<p>No requirement entries.</p>';
        ontologyReportContainer.innerHTML = html;
        return;
      }

      html += '<table border="1" cellpadding="4" cellspacing="0">';
      html += '<thead><tr>' +
              '<th>Requirement ID</th>' +
              '<th>Type</th>' +
              '<th>Status</th>' +
              '<th>Failed Resources</th>' +
              '</tr></thead><tbody>';

      for (const r of report.requirements) {
        const typeLabel = r.type === 'recommendation' ? 'recommendation' : 'requirement';
        const failedCount = r.failedResourcesCount || 0;

        html += '<tr>' +
                '<td>' + escapeHtml(r.id) + '</td>' +
                '<td>' + escapeHtml(typeLabel) + '</td>' +
                '<td>' + escapeHtml(r.status) + '</td>' +
                '<td>' + escapeHtml(String(failedCount)) + '</td>' +
                '</tr>';
      }

      html += '</tbody></table>';
      ontologyReportContainer.innerHTML = html;
    }

    function downloadTextFile(filename, text, mimeType) {
      const blob = new Blob([text], { type: mimeType || 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    function toCsv(results, ontologyIri) {
      if (!Array.isArray(results) || results.length === 0) {
        return 'ontologyIri,resource,queryId,requirementId,status,severity,scope\n';
      }
      const header = ['ontologyIri', 'resource', 'queryId', 'requirementId', 'status', 'severity', 'scope'];
      const rows = [header.join(',')];

      for (const row of results) {
        const cols = [
          ontologyIri || '',
          row.resource || '',
          row.queryId || '',
          row.requirementId || '',
          row.status || '',
          row.severity || '',
          row.scope || ''
        ].map(v => {
          const s = String(v).replace(/"/g, '""');
          return `"${s}"`;
        });
        rows.push(cols.join(','));
      }
      return rows.join('\n');
    }

    function ontologyReportToYaml(report) {
      if (!report) return '# No ontology report\n';

      const lines = [];
      lines.push('ontologyIri: "' + String(report.ontologyIri).replace(/"/g, '\\"') + '"');
      lines.push('status: "' + String(report.statusLabel).replace(/"/g, '\\"') + '"');
      lines.push('requirements:');
      for (const r of report.requirements || []) {
        lines.push('  - id: "' + String(r.id).replace(/"/g, '\\"') + '"');
        lines.push('    type: "' + String(r.type).replace(/"/g, '\\"') + '"');
        lines.push('    status: "' + String(r.status).replace(/"/g, '\\"') + '"');
        lines.push('    failedResourcesCount: ' + (r.failedResourcesCount || 0));
      }
      return lines.join('\n') + '\n';
    }

    btnRun.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) {
        alert('Please select an ontology file first.');
        return;
      }

      statusEl.textContent = 'Reading file…';
      tableContainer.innerHTML = '';
      ontologyReportContainer.innerHTML = '';
      lastResults = null;
      lastPerResource = null;
      lastOntologyReport = null;

      const text = await file.text();
      statusEl.textContent = 'Running checks…';

      try {
        const { results, resources, ontologyIri } = await window.OntologyChecks.evaluateAllQueries(
          text,
          file.name
        );
        console.log('Normalized results:', results);
        console.log('Candidate resources (labeled):', resources);
        console.log('Ontology IRI:', ontologyIri);

        const manifestRes = await fetch('queries/manifest.json');
        const manifest = await manifestRes.json();

        const perResource = window.OntologyChecks.computePerResourceCuration(
          results,
          manifest,
          resources
        );
        console.log('Per-resource curation:', perResource);

        const ontologyReport = window.OntologyChecks.computeOntologyReport(
          results,
          manifest,
          ontologyIri
        );
        console.log('Ontology report:', ontologyReport);

        lastResults = results;
        lastPerResource = perResource;
        lastOntologyReport = ontologyReport;

        renderOntologyReport(ontologyReport);
        renderCurationTable(perResource);

        statusEl.textContent =
          `Checks completed. ${results.length} result rows across ${perResource.length} resources.`;
      } catch (err) {
        console.error('Error running checks:', err);
        statusEl.textContent = 'Error: ' + err.message;
      }
    });

    btnCsv.addEventListener('click', () => {
      if (!lastResults) {
        alert('No results to export yet. Run checks first.');
        return;
      }
      const ontologyIri = lastOntologyReport ? lastOntologyReport.ontologyIri : '';
      const csv = toCsv(lastResults, ontologyIri);
      downloadTextFile('ontology-check-results.csv', csv, 'text/csv');
    });

    btnYaml.addEventListener('click', () => {
      if (!lastOntologyReport) {
        alert('No ontology report to export yet. Run checks first.');
        return;
      }
      const yaml = ontologyReportToYaml(lastOntologyReport);
      downloadTextFile('ontology-report.yaml', yaml, 'text/yaml');
    });
  </script>
  
</body>
</html>
